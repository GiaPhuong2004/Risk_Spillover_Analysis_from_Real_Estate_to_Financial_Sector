---
title: Risk Spillover Analysis from Real Estate to Financial Sector
author: "GiaPhuong"
output:
  html_document:
    df_print: paged
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(readxl)
library(tidyr)
library(dplyr)
library(purrr)
library(stringr)
library(tseries)
library(FinTS)
library(fBasics)
library(urca)
library(lmtest)
library(forecast)
library(rugarch)
library(ggplot2)
library(Metrics)
library(rmgarch)
library(rugarch)
library(psych)
library(fGarch)
library(copula)
library(qrmtools)
library(lubridate)
```

## 1. X·ª© l√≠ d·ªØ li·ªáu ƒë·∫ßu v√†o
### 1.1. Nh·∫≠p d·ªØ li·ªáu
```{r}
# Danh s√°ch file path (m·ªói file l√† m·ªôt ng√†nh)
file_paths <- list(
  "D:/Khoa_luan/D·ªØ li·ªáu L·ªãch s·ª≠ Real Estate.xlsx",
  "D:/Khoa_luan/D·ªØ li·ªáu L·ªãch s·ª≠ Banks.xlsx",
  "D:/Khoa_luan/D·ªØ li·ªáu L·ªãch s·ª≠ Financial Services.xlsx",
  "D:/Khoa_luan/D·ªØ li·ªáu L·ªãch s·ª≠ Insurance.xlsx"
)

# H√†m chuy·ªÉn ƒë·ªïi gi√° tr·ªã KL
convert_value <- function(x) {
  if (is.na(x)) return(NA_real_)
  if (str_ends(x, "K")) {
    num <- as.numeric(str_remove(x, "K"))
    return(num * 1e3)
  } else if (str_ends(x, "M")) {
    num <- as.numeric(str_remove(x, "M"))
    return(num * 1e6)
  } else {
    return(suppressWarnings(as.numeric(x)))
  }
}

# Kh·ªüi t·∫°o danh s√°ch ƒë·ªÉ l∆∞u d·ªØ li·ªáu t·ª´ c√°c file
merged_cp_list <- list()
merged_kl_list <- list()

# X·ª≠ l√Ω t·ª´ng file
for (file_path in file_paths) {
  sheet_names <- excel_sheets(file_path)
  
  # T√™n ng√†nh t·ª´ file path (Real Estate, Banks, Financial Services, Insurance)
  industry_name <- str_extract(file_path, "(?<=D·ªØ li·ªáu L·ªãch s·ª≠ ).*(?=\\.xlsx)")
  
  # X·ª≠ l√Ω gi√° ƒë√≥ng c·ª≠a
  data_cp <- map(sheet_names, function(sheet) {
    stock_code <- sub("D·ªØ li·ªáu L·ªãch s·ª≠ ", "", sheet)
    
    read_excel(file_path, sheet = sheet) %>%
      select(Ng√†y, `L·∫ßn cu·ªëi`) %>%
      mutate(Date = as.Date(Ng√†y, format = "%d/%m/%Y")) %>%
      select(Date, `L·∫ßn cu·ªëi`) %>%
      rename(!!stock_code := `L·∫ßn cu·ªëi`)
  })
  
  # G·ªôp theo Date cho gi√° ƒë√≥ng c·ª≠a
  merged_cp <- purrr::reduce(data_cp, full_join, by = "Date") %>%
    arrange(Date)
  
  # L∆∞u DataFrame gi√° ƒë√≥ng c·ª≠a cho ng√†nh
  merged_cp_list[[industry_name]] <- merged_cp
  
  # X·ª≠ l√Ω kh·ªëi l∆∞·ª£ng giao d·ªãch
  data_kl <- map(sheet_names, function(sheet) {
    stock_code <- sub("D·ªØ li·ªáu L·ªãch s·ª≠ ", "", sheet)
    
    read_excel(file_path, sheet = sheet) %>%
      select(Ng√†y, KL) %>%
      mutate(Date = as.Date(Ng√†y, format = "%d/%m/%Y")) %>%
      select(Date, KL) %>%
      rename(!!stock_code := KL)
  })
  
  # G·ªôp theo Date cho kh·ªëi l∆∞·ª£ng giao d·ªãch
  merged_kl <- purrr::reduce(data_kl, full_join, by = "Date") %>%
    arrange(Date)
  
  # Chuy·ªÉn ƒë·ªïi gi√° tr·ªã KL
  merged_kl <- merged_kl %>%
    mutate(across(-Date, ~ sapply(.x, convert_value)))
  
  # L∆∞u DataFrame kh·ªëi l∆∞·ª£ng giao d·ªãch cho ng√†nh
  merged_kl_list[[industry_name]] <- merged_kl
}

# Gi·ªù c√≥ 8 DataFrame ri√™ng bi·ªát cho t·ª´ng ng√†nh

# In k·∫øt qu·∫£ cho t·ª´ng DataFrame (gi√° ƒë√≥ng c·ª≠a v√† kh·ªëi l∆∞·ª£ng giao d·ªãch)
print(head(merged_cp_list[["Real Estate"]]))  # Gi√° ƒë√≥ng c·ª≠a Real Estate
print(head(merged_kl_list[["Real Estate"]]))  # Kh·ªëi l∆∞·ª£ng giao d·ªãch Real Estate

print(head(merged_cp_list[["Banks"]]))        # Gi√° ƒë√≥ng c·ª≠a Banks
print(head(merged_kl_list[["Banks"]]))        # Kh·ªëi l∆∞·ª£ng giao d·ªãch Banks

print(head(merged_cp_list[["Financial Services"]]))  # Gi√° ƒë√≥ng c·ª≠a Financial Services
print(head(merged_kl_list[["Financial Services"]]))  # Kh·ªëi l∆∞·ª£ng giao d·ªãch Financial Services

print(head(merged_cp_list[["Insurance"]]))  # Gi√° ƒë√≥ng c·ª≠a Insurance
print(head(merged_kl_list[["Insurance"]]))  # Kh·ªëi l∆∞·ª£ng giao d·ªãch Insurance
```

### 1.2. T√≠nh gi√° ƒë√≥ng c·ª≠a v√† l·ª£i su·∫•t t·ª´ng ng√†nh
```{r}
# T√≠nh gi√° ƒë√≥ng c·ª≠a ng√†nh theo KL cho t·ª´ng ng√†nh
industry_avg_cp <- map2(merged_cp_list, merged_kl_list, function(cp_df, kl_df) {
  # Thay NA b·∫±ng 0 tr∆∞·ªõc khi t√≠nh
  cp_filled <- cp_df %>% mutate(across(-Date, ~ replace_na(.x, 0)))
  kl_filled <- kl_df %>% mutate(across(-Date, ~ replace_na(.x, 0)))
  
  # T√≠nh gi√° tr·ªã: sum(cp * kl) / sum(kl)
  weighted_cp <- map2_dfc(cp_filled[-1], kl_filled[-1], ~ .x * .y)
  total_value <- rowSums(weighted_cp, na.rm = TRUE)
  total_volume <- rowSums(kl_filled[-1], na.rm = TRUE)
  
  avg_price <- ifelse(total_volume == 0, NA, total_value / total_volume)
  
  tibble(Date = cp_df$Date, Avg_Closing_Price = avg_price)
})

# ƒê·∫∑t t√™n cho c√°c ng√†nh trong danh s√°ch
names(industry_avg_cp) <- names(merged_cp_list)

# ƒê·ªïi t√™n c·ªôt gi√° ƒë√≥ng c·ª≠a ng√†nh theo t√™n ng√†nh
industry_avg_cp_named <- imap(industry_avg_cp, ~ rename(.x, !!.y := Avg_Closing_Price))

# G·ªôp l·∫°i th√†nh 1 b·∫£ng duy nh·∫•t theo Date
industry_cp_combined <- purrr::reduce(industry_avg_cp_named, full_join, by = "Date") %>%
  arrange(Date)

# Xem k·∫øt qu·∫£
head(industry_cp_combined)
```

```{r}
# --- T√≠nh gi√° ƒë√≥ng c·ª≠a trung b√¨nh c·ªßa ng√†nh Finance (Banks + Financial Services + Insurance) ---

# L·∫•y d·ªØ li·ªáu gi√° v√† KL c·ªßa 3 ng√†nh t√†i ch√≠nh
finance_cp_list <- merged_cp_list[c("Banks", "Financial Services", "Insurance")]
finance_kl_list <- merged_kl_list[c("Banks", "Financial Services", "Insurance")]

# G·ªôp to√†n b·ªô c·ªï phi·∫øu trong 3 ng√†nh th√†nh 1 b·∫£ng l·ªõn
finance_cp_all <- purrr::reduce(finance_cp_list, full_join, by = "Date")
finance_kl_all <- purrr::reduce(finance_kl_list, full_join, by = "Date")

# --- thay NA = 0 tr∆∞·ªõc khi t√≠nh ---
finance_cp_filled <- finance_cp_all %>% mutate(across(-Date, ~ replace_na(.x, 0)))
finance_kl_filled <- finance_kl_all %>% mutate(across(-Date, ~ replace_na(.x, 0)))

# T√≠nh gi√° ƒë√≥ng c·ª≠a trung b√¨nh c√≥ tr·ªçng s·ªë: sum(cp * kl) / sum(kl)
weighted_cp_fin <- map2_dfc(finance_cp_filled[-1], finance_kl_filled[-1], ~ .x * .y)
total_value_fin <- rowSums(weighted_cp_fin, na.rm = TRUE)
total_volume_fin <- rowSums(finance_kl_filled[-1], na.rm = TRUE)

avg_finance_price <- ifelse(total_volume_fin == 0, NA, total_value_fin / total_volume_fin)

# T·∫°o b·∫£ng Finance
finance_cp <- tibble(Date = finance_cp_all$Date, Finance = avg_finance_price)

# G·ªôp th√™m v√†o industry_cp_combined
industry_cp_combined <- industry_cp_combined %>%
  full_join(finance_cp, by = "Date") %>%
  arrange(Date)

# Xem k·∫øt qu·∫£
head(industry_cp_combined)
```

```{r}
#Loc data giai doan 2018 - 2024
industry_closing_price <- industry_cp_combined %>%
  filter(Date >= as.Date("2018-01-01") & Date <= as.Date("2024-12-31"))
print(head(industry_closing_price))
```
```{r}
#T√≠nh return rate theo c√¥ng th·ª©c log(Pt / Pt-1) * 100
industry_return <- industry_closing_price %>%
  arrange(Date) %>%  # ƒê·∫£m b·∫£o d·ªØ li·ªáu theo th·ª© t·ª± th·ªùi gian
  mutate(
    `Real Estate` = 100 * log(`Real Estate` / lag(`Real Estate`)),
    Banks = 100 * log(Banks / lag(Banks)),
    `Financial Services` = 100 * log(`Financial Services` / lag(`Financial Services`)),
    `Insurance` = 100 * log(`Insurance` / lag(`Insurance`)),
    `Finance` = 100 * log(`Finance` / lag(`Finance`)),
  )
print(head(industry_return))
```

```{r}
colnames(industry_closing_price) <- c("Date", "RealEstate", "Banks", "FinancialServices", "Insurance", "Finance")

# L·∫•y danh s√°ch c√°c ng√†nh
industries <- colnames(industry_closing_price)[colnames(industry_closing_price) != "Date"]

# V√≤ng l·∫∑p v·∫Ω t·ª´ng ng√†nh
for (ind in industries) {
  p <- ggplot(industry_closing_price, aes_string(x = "Date", y = ind)) +
    geom_line(color = "steelblue") +
    labs(
      title = paste("Gi√° ƒë√≥ng c·ª≠a ng√†nh", ind, "2018-2024"),
      x = "Ng√†y",
      y = "Gi√° ƒë√≥ng c·ª≠a"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
  
  print(p)
}
```
```{r}
colnames(industry_return) <- c("Date", "RealEstate", "Banks", "FinancialServices", "Insurance", "Finance")

# L·∫•y danh s√°ch c√°c ng√†nh
industries <- colnames(industry_return)[colnames(industry_return) != "Date"]

# V√≤ng l·∫∑p v·∫Ω t·ª´ng ng√†nh
for (ind in industries) {
  p <- ggplot(industry_return, aes_string(x = "Date", y = ind)) +
    geom_line(color = "steelblue") +
    labs(
      title = paste("L·ª£i su·∫•t ng√†nh", ind, "2018-2024"),
      x = "Ng√†y",
      y = "L·ª£i su·∫•t"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
  
  print(p)
}
```

```{r}
# V√≤ng l·∫∑p v·∫Ω histogram + density cho t·ª´ng ng√†nh
for (ind in industries) {
  p <- ggplot(industry_return, aes_string(x = ind)) +
    geom_histogram(aes(y = ..density..),   # histogram theo m·∫≠t ƒë·ªô
                   bins = 40,            # s·ªë c·ªôt
                   fill = "steelblue",
                   color = "white",
                   alpha = 0.7) +
    geom_density(aes(y = ..density..),     # ph·ªß ƒë∆∞·ªùng density
                 color = "red",
                 size = 1) +
    labs(
      title = paste("Ph√¢n ph·ªëi l·ª£i su·∫•t ng√†nh", ind, "2018‚Äì2024"),
      x = "L·ª£i su·∫•t",
      y = "T·∫ßn su·∫•t"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
  
  print(p)
}
```

```{r}
describe(na.omit(industry_return[, c("RealEstate", "Banks", "FinancialServices","Insurance","Finance")]))
```

## 2.M√¥ h√¨nh ARIMA 
### 2.1. Ki·ªÉm ƒë·ªãnh JB v√† t√≠nh d·ª´ng 
```{r}
#Ki·ªÉm ƒë·ªãnh JB cho t·ª´ng ng√†nh
jb_results <- lapply(na.omit(industry_return[, c("RealEstate", "Banks", "FinancialServices","Insurance","Finance")]), function(x) jarque.bera.test(na.omit(x)))
jb_results
```
```{r}
#Ki·ªÉm ƒë·ªãnh ADF
for (ind in industries) {
  cat("\n============================\n")
  cat("K·∫øt qu·∫£ ADF test cho ng√†nh:", ind, "\n")
  cat("============================\n\n")
  
  series <- na.omit(industry_return)[[ind]]
  
  # Ki·ªÉm ƒë·ªãnh ADF v·ªõi trend
  adf_trend <- ur.df(series, type = "trend", selectlags = "AIC")
  cat(">> ADF v·ªõi trend:\n")
  print(summary(adf_trend))
  
  # Ki·ªÉm ƒë·ªãnh ADF v·ªõi drift
  adf_drift <- ur.df(series, type = "drift", selectlags = "AIC")
  cat("\n>> ADF v·ªõi drift:\n")
  print(summary(adf_drift))
  
  # Ki·ªÉm ƒë·ªãnh ADF kh√¥ng c√≥ h·∫±ng s·ªë hay trend
  adf_none <- ur.df(series, type = "none", selectlags = "AIC")
  cat("\n>> ADF kh√¥ng constant, kh√¥ng trend:\n")
  print(summary(adf_none))
}
```
```{r}
for (ind in industries) {
  cat("\n============================\n")
  cat("Ki·ªÉm ƒë·ªãnh Ljung‚ÄìBox cho ng√†nh:", ind, "\n")
  cat("============================\n\n")
  
  series <- na.omit(industry_return)[[ind]]
  
  # Ki·ªÉm ƒë·ªãnh Ljung-Box ·ªü nhi·ªÅu ƒë·ªô tr·ªÖ (lag)
  for (lag in c(1, 5, 10)) {
    lb_test <- Box.test(series, lag = lag, type = "Ljung-Box")
    cat("Lag =", lag, " | p-value =", lb_test$p.value, "\n")
  }
}
```

### 2.2. ACF v√† PACF
```{r}
#ACF, PCF
for (ind in industries) {
  series <- na.omit(industry_return[[ind]])
  
  # ACF plot with title
  acf(series, main = paste("ACF -", ind))
  
  # PACF plot with title
  pacf(series, main = paste("PACF -", ind))
}
```

### 2.3. Ch·∫°y m√¥ h√¨nh ARIMA(p,d,q)
```{r}
# T·∫°o list r·ªóng ƒë·ªÉ l∆∞u k·∫øt qu·∫£ m√¥ h√¨nh
arma_models <- list()

# L·∫∑p qua t·ª´ng ng√†nh
for (ind in industries) {
  cat("üîπ ƒêang ch·∫°y auto.arima cho ng√†nh:", ind, "\n")
  
  y <- industry_return[[ind]]
  
  # Ch·∫°y auto.arima
  fit <- auto.arima(y,
                    d = 0,            # returns th∆∞·ªùng ƒë√£ d·ª´ng
                    seasonal = FALSE, 
                    ic = "aic",      
                    stepwise = FALSE, 
                    approximation = FALSE)
  
  # L∆∞u m√¥ h√¨nh v√†o list
  arma_models[[ind]] <- fit
  
  # In t√≥m t·∫Øt k·∫øt qu·∫£
  print(summary(fit))
  cat("------------------------------------------------------------\n\n")
}
```
```{r}
#Ki·ªÉm ƒë·ªãnh Ljung-Box
# Fit ARIMA(2,0,4) cho t·∫•t c·∫£ c√°c chu·ªói
fixed_arima_models <- list()

for (ind in industries) {
  cat("Fitting ARIMA(2,0,4) for ng√†nh:", ind, "\n")
  fixed_arima_models[[ind]] <- Arima(na.omit(industry_return[[ind]]), order = c(2,0,4),include.mean = FALSE)
  }
library(FinTS)

lags_to_check <- c(1, 5, 10)

for (ind in names(fixed_arima_models)) {
  cat("üîπ Ng√†nh:", ind, "\n")
  fit <- fixed_arima_models[[ind]]
  
  # Residuals
  resid <- residuals(fit)
  
  # Ki·ªÉm ƒë·ªãnh cho t·ª´ng lag
  for (lag_val in lags_to_check) {
    lb <- Box.test(resid, lag = lag_val, type = "Ljung-Box")
    cat("  Ljung-Box lag(", lag_val, "): p-value =", round(lb$p.value, 4))
    
    if (lb$p.value < 0.05) {
      cat(" ‚ö†Ô∏è  Ph·∫ßn d∆∞ c√≤n t·ª± t∆∞∆°ng quan.\n")
    } else {
      cat(" ‚úÖ  Ph·∫ßn d∆∞ kh√¥ng c√≥ t·ª± t∆∞∆°ng quan ƒë√°ng k·ªÉ.\n")
    }
  }
  cat("------------------------------------------------------------\n")
}
```

### 2.4. Ki·ªÉm ƒë·ªãnh Engle
```{r}
#Engle-ARCH Test
# Fit ARIMA(2,0,4) cho t·∫•t c·∫£ c√°c chu·ªói
fixed_arima_models <- list()

for (ind in industries) {
  cat("Fitting ARIMA(2,0,4) for ng√†nh:", ind, "\n")
  fixed_arima_models[[ind]] <- Arima(na.omit(industry_return[[ind]]), order = c(2,0,4),include.mean = FALSE)
  }
library(FinTS)

lags_to_check <- c(1, 5, 10)

for (ind in names(fixed_arima_models)) {
  cat("üîπ Ng√†nh:", ind, "\n")
  fit <- fixed_arima_models[[ind]]
  
  # Residuals
  resid <- residuals(fit)
  
  # ARCH tests
  for (lag_val in lags_to_check) {
    arch_test <- ArchTest(resid, lags = lag_val)
    
    cat("  Engle's ARCH Test (lag =", lag_val, "): p-value =", round(arch_test$p.value, 4), "\n")
    
    if (arch_test$p.value < 0.05) {
      cat("  ‚ö†Ô∏è  C√≥ ARCH effect ‚Üí m√¥ h√¨nh ARIMA(2,0,4) KH√îNG ƒë·ªß, n√™n xem x√©t GARCH.\n")
    } else {
      cat("  ‚úÖ  Kh√¥ng c√≥ ARCH effect ƒë√°ng k·ªÉ.\n")
    }
  }
  cat("------------------------------------------------------------\n")
}
```


## 3. M√¥ h√¨nh GARCH
### 3.1. sGARCH
```{r}
#Ch·∫°y ARMA-sGARCH

#-------------------------
# ARMA-GARCH cho nhi·ªÅu ng√†nh & ph√¢n ph·ªëi
#-------------------------

library(rugarch)
library(tseries)   # cho ArchTest

# Danh s√°ch ph√¢n ph·ªëi th·ª≠
dist_list <- c("norm", "std", "sstd", "ged", "sged")

# T·∫°o dataframe l∆∞u k·∫øt qu·∫£
results <- data.frame(
  Industry = character(),
  Distribution = character(),
  omega = numeric(),
  omega_sd = numeric(),
  alpha1 = numeric(),
  alpha1_sd = numeric(),
  beta1 = numeric(),
  beta1_sd = numeric(),
  shape = numeric(),
  shape_sd = numeric(),
  skew = numeric(),
  skew_sd = numeric(),
  LLF = numeric(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)

# V√≤ng l·∫∑p qua ng√†nh (b·ªè c·ªôt Date)
for (ind in names(industry_return)[names(industry_return) != "Date"]) {
  
  ret <- na.omit(as.numeric(industry_return[[ind]]))  # ch·ªâ l·∫•y gi√° tr·ªã s·ªë
  
  # L·∫•y order ARMA t·ª´ng ng√†nh
  p <- 2
  q <- 4
  
  cat("üîπ Ng√†nh:", ind, "\n")
  
  # V√≤ng l·∫∑p qua ph√¢n ph·ªëi
  for (dist in dist_list) {
    spec <- ugarchspec(
      variance.model = list(model = "sGARCH", garchOrder = c(3,1)),
      mean.model = list(armaOrder = c(p, q),include.mean = FALSE),
      distribution.model = dist
    )
    
    garch_fit <- tryCatch({
      ugarchfit(spec = spec, data = ret)
    }, error = function(e) {
      cat("  ‚ö†Ô∏è L·ªói fit GARCH cho", dist, "\n")
      return(NULL)
    })
    
    if (!is.null(garch_fit)) {
      # L·∫•y th√¥ng s·ªë
      coefs <- coef(garch_fit)
      se <- sqrt(diag(garch_fit@fit$matcoef))
      
      shape <- if("shape" %in% names(coefs)) coefs["shape"] else NA
      shape_sd <- if("shape" %in% names(se)) se["shape"] else NA
      skew <- if("skew" %in% names(coefs)) coefs["skew"] else NA
      skew_sd <- if("skew" %in% names(se)) se["skew"] else NA
      
      # L∆∞u k·∫øt qu·∫£
      results <- rbind(results, data.frame(
        Industry = ind,
        Distribution = dist,
        omega = coefs["omega"], omega_sd = se["omega"],
        alpha1 = coefs["alpha1"], alpha1_sd = se["alpha1"],
        beta1 = coefs["beta1"], beta1_sd = se["beta1"],
        shape = shape, shape_sd = shape_sd,
        skew = skew, skew_sd = skew_sd,
        LLF = likelihood(garch_fit),
        AIC = infocriteria(garch_fit)[1],
        BIC = infocriteria(garch_fit)[2]
      ))
      
      cat("  ‚úÖ Fit th√†nh c√¥ng cho", dist, "\n")
      
      # Ki·ªÉm ƒë·ªãnh Ljung-Box tr√™n ph·∫ßn d∆∞ chu·∫©n h√≥a
      resid_std <- residuals(garch_fit, standardize = TRUE)
      for (lag in c(1,5,10)) {
        lb <- Box.test(resid_std, lag = lag, type = "Ljung-Box")
        cat("    Ljung-Box lag(", lag, "): p-value =", round(lb$p.value,4), "\n")
      }
      
      # Ki·ªÉm ƒë·ªãnh Engle ARCH
      for (lag in c(1,5,10)) {
        arch <- ArchTest(resid_std, lags = lag)
        cat("    Engle ARCH lag(", lag, "): p-value =", round(arch$p.value,4), "\n")
      }
      
      cat("------------------------------------------------------------\n")
    }
  }
}


# Xem k·∫øt qu·∫£
print(results)

```

### 3.2. eGARCH
```{r}
#--------------------------------------------------------
# ARMA(2,4) ‚Äì EGARCH(1,1) v·ªõi x·ª≠ l√Ω l·ªói h·ªôi t·ª•
#--------------------------------------------------------

library(rugarch)
library(tseries)

dist_list <- c("norm", "std", "sstd", "ged", "sged")

results_egarch <- data.frame(
  Industry = character(),
  Distribution = character(),
  omega = numeric(),
  omega_sd = numeric(),
  alpha1 = numeric(),
  alpha1_sd = numeric(),
  gamma1 = numeric(),
  gamma1_sd = numeric(),
  beta1 = numeric(),
  beta1_sd = numeric(),
  shape = numeric(),
  shape_sd = numeric(),
  skew = numeric(),
  skew_sd = numeric(),
  LLF = numeric(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)

for (ind in names(industry_return)[names(industry_return) != "Date"]) {
  
  ret <- na.omit(as.numeric(industry_return[[ind]]))
  
  p <- 2
  q <- 4
  
  cat("üîπ Ng√†nh:", ind, "\n")
  
  for (dist in dist_list) {
    
    spec <- ugarchspec(
      variance.model = list(model = "eGARCH", garchOrder = c(3,1)),
      mean.model = list(armaOrder = c(p, q), include.mean = FALSE),
      distribution.model = dist
    )
    
    garch_fit <- tryCatch({
      ugarchfit(spec = spec, data = ret)
    }, error = function(e) {
      cat("  ‚ö†Ô∏è L·ªói fit EGARCH cho", dist, "\n")
      return(NULL)
    })
    
    # N·∫øu NULL ‚Üí b·ªè
    if (is.null(garch_fit)) next
    
    # N·∫øu kh√¥ng h·ªôi t·ª• ‚Üí b·ªè
    if (garch_fit@fit$convergence != 0) {
      cat("  ‚ùå Kh√¥ng h·ªôi t·ª• ‚Äì b·ªè m√¥ h√¨nh", dist, "\n")
      next
    }
    
    # Ki·ªÉm tra AIC/BIC
    ic <- tryCatch(infocriteria(garch_fit), error=function(e) NULL)
    if (is.null(ic) || any(is.na(ic))) {
      cat("  ‚ùå AIC/BIC b·ªã NA ‚Äì b·ªè m√¥ h√¨nh", dist, "\n")
      next
    }
    
    # N·∫øu OK ‚Üí l·∫•y k·∫øt qu·∫£
    coefs <- coef(garch_fit)
    se <- sqrt(diag(garch_fit@fit$matcoef))
    
    shape <- if("shape" %in% names(coefs)) coefs["shape"] else NA
    shape_sd <- if("shape" %in% names(se)) se["shape"] else NA
    
    skew <- if("skew" %in% names(coefs)) coefs["skew"] else NA
    skew_sd <- if("skew" %in% names(se)) se["skew"] else NA
    
    results_egarch <- rbind(results_egarch, data.frame(
      Industry = ind,
      Distribution = dist,
      omega = coefs["omega"], omega_sd = se["omega"],
      alpha1 = coefs["alpha1"], alpha1_sd = se["alpha1"],
      gamma1 = coefs["gamma1"], gamma1_sd = se["gamma1"],
      beta1 = coefs["beta1"], beta1_sd = se["beta1"],
      shape = shape, shape_sd = shape_sd,
      skew = skew, skew_sd = skew_sd,
      LLF = likelihood(garch_fit),
      AIC = ic[1],
      BIC = ic[2]
    ))
    
    cat("  ‚úÖ Fit th√†nh c√¥ng ‚Äì l∆∞u k·∫øt qu·∫£ cho", dist, "\n")
    cat("------------------------------------------------------------\n")
  }
}

print(results_egarch)

```

### 3.3. GJR-GARCH
```{r}
library(rugarch)
library(tseries)  # cho ArchTest

# Danh s√°ch ph√¢n ph·ªëi th·ª≠
dist_list <- c("norm", "std", "sstd", "ged", "sged")

# Dataframe l∆∞u k·∫øt qu·∫£
results_gjr <- data.frame(
  Industry = character(),
  Distribution = character(),
  omega = numeric(),
  omega_sd = numeric(),
  alpha1 = numeric(),
  alpha1_sd = numeric(),
  gamma1 = numeric(),
  gamma1_sd = numeric(),
  beta1 = numeric(),
  beta1_sd = numeric(),
  shape = numeric(),
  shape_sd = numeric(),
  skew = numeric(),
  skew_sd = numeric(),
  LLF = numeric(),
  AIC = numeric(),
  BIC = numeric(),
  stringsAsFactors = FALSE
)

# Tham s·ªë ARMA c·ªë ƒë·ªãnh (ARMA(2,4))
p <- 2
q <- 4

# V√≤ng l·∫∑p qua c√°c ng√†nh
for (ind in names(industry_return)[names(industry_return) != "Date"]) {
  
  ret <- na.omit(as.numeric(industry_return[[ind]]))
  cat("üîπ Ng√†nh:", ind, "\n")
  
  for (dist in dist_list) {
    spec <- ugarchspec(
      variance.model = list(model = "gjrGARCH", garchOrder = c(3,2)),
      mean.model = list(armaOrder = c(p, q), include.mean = FALSE),
      distribution.model = dist
    )
    
    gjr_fit <- tryCatch({
      ugarchfit(spec = spec, data = ret, solver = "hybrid", solver.control = list(trace = 0))
    }, error = function(e) {
      cat("  ‚ö†Ô∏è Kh√¥ng h·ªôi t·ª• ‚Äì b·ªè m√¥ h√¨nh", dist, "\n")
      return(NULL)
    })
    
    if (!is.null(gjr_fit)) {
      coefs <- coef(gjr_fit)
      se <- sqrt(diag(gjr_fit@fit$matcoef))
      
      shape <- if("shape" %in% names(coefs)) coefs["shape"] else NA
      shape_sd <- if("shape" %in% names(se)) se["shape"] else NA
      skew <- if("skew" %in% names(coefs)) coefs["skew"] else NA
      skew_sd <- if("skew" %in% names(se)) se["skew"] else NA
      
      results_gjr <- rbind(results_gjr, data.frame(
        Industry = ind,
        Distribution = dist,
        omega = coefs["omega"], omega_sd = se["omega"],
        alpha1 = coefs["alpha1"], alpha1_sd = se["alpha1"],
        alpha2 = coefs["alpha2"], alpha1_sd = se["alpha2"],
        alpha3 = coefs["alpha3"], alpha1_sd = se["alpha3"],
        gamma1 = coefs["gamma1"], gamma1_sd = se["gamma1"],
        gamma2 = coefs["gamma2"], gamma1_sd = se["gamma2"],
        gamma3 = coefs["gamma3"], gamma1_sd = se["gamma3"],
        beta1 = coefs["beta1"], beta1_sd = se["beta1"],
        beta2 = coefs["beta2"], beta1_sd = se["beta2"],
        shape = shape, shape_sd = shape_sd,
        skew = skew, skew_sd = skew_sd,
        LLF = likelihood(gjr_fit),
        AIC = infocriteria(gjr_fit)[1],
        BIC = infocriteria(gjr_fit)[2]
      ))
      
      cat("  ‚úÖ Fit th√†nh c√¥ng cho", dist, "\n")
      
      # Ki·ªÉm ƒë·ªãnh Ljung-Box tr√™n ph·∫ßn d∆∞ chu·∫©n h√≥a
      resid_std <- residuals(gjr_fit, standardize = TRUE)
      for (lag in c(1,5,10)) {
        lb <- Box.test(resid_std, lag = lag, type = "Ljung-Box")
        cat("    Ljung-Box lag(", lag, "): p-value =", round(lb$p.value,4), "\n")
      }
      
      # Ki·ªÉm ƒë·ªãnh Engle ARCH
      for (lag in c(1,5,10)) {
        arch <- ArchTest(resid_std, lags = lag)
        cat("    Engle ARCH lag(", lag, "): p-value =", round(arch$p.value,4), "\n")
      }
      
      cat("------------------------------------------------------------\n")
    }
  }
}

# Xem k·∫øt qu·∫£
print(results_gjr)
```


### 3.4. Ch·ªçn m√¥ h√¨nh t·ªëi ∆∞u
```{r}
#Ch·ªçn ƒë∆∞·ª£c m√¥ h√¨nh GJR GARCH sged (3,2) 
#RealEstate
spec_realestate <- ugarchspec(
      variance.model = list(model = "gjrGARCH", garchOrder = c(3,2)),
      mean.model = list(armaOrder = c(2, 4), include.mean = FALSE),
      distribution.model = "sged")
fit_realestate <-  ugarchfit(spec = spec_realestate, data = na.omit(industry_return$RealEstate))
resid_realestate <- as.numeric(residuals(fit_realestate,standardize = TRUE))

#Banks
spec_banks <- ugarchspec(
      variance.model = list(model = "gjrGARCH", garchOrder = c(3,2)),
      mean.model = list(armaOrder = c(2, 4), include.mean = FALSE),
      distribution.model = "sged")
fit_banks <-  ugarchfit(spec = spec_banks, data = na.omit(industry_return$Banks))
resid_banks <- as.numeric(residuals(fit_banks,standardize = TRUE))

#FinancialServices
spec_financialservices <- ugarchspec(
      variance.model = list(model = "gjrGARCH", garchOrder = c(3,2)),
      mean.model = list(armaOrder = c(2, 4), include.mean = FALSE),
      distribution.model = "sged")
fit_financialservices <-  ugarchfit(spec = spec_financialservices, data = na.omit(industry_return$FinancialServices))
resid_financialservices <- as.numeric(residuals(fit_financialservices,standardize = TRUE))

#Insurance
spec_insurance <- ugarchspec(
      variance.model = list(model = "gjrGARCH", garchOrder = c(3,2)),
      mean.model = list(armaOrder = c(2, 4), include.mean = FALSE),
      distribution.model = "sged")
fit_insurance <-  ugarchfit(spec = spec_insurance, data = na.omit(industry_return$Insurance))
resid_insurance <- as.numeric(residuals(fit_insurance,standardize = TRUE))

#Finance
spec_finance <- ugarchspec(
      variance.model = list(model = "gjrGARCH", garchOrder = c(3,2)),
      mean.model = list(armaOrder = c(2, 4), include.mean = FALSE),
      distribution.model = "sged")
fit_finance <-  ugarchfit(spec = spec_finance, data = na.omit(industry_return$Finance))
resid_finance <- as.numeric(residuals(fit_finance,standardize = TRUE))
```

## 4. Copula
```{r}
# =============================================================
#  Chuy·ªÉn ph·∫ßn d∆∞ chu·∫©n ho√° sang U(0,1)
# =============================================================

# RealEstate
u_realestate <- psged(resid_realestate,
                      mean = 0,
                      sd   = 1,
                      nu   = coef(fit_realestate)["shape"],
                      xi   = coef(fit_realestate)["skew"])
ks_realestate <- ks.test(u_realestate, "punif", 0, 1)
cat("Kolmogorov‚ÄìSmirnov p-value (RealEstate):", round(ks_realestate$p.value, 4), "\n")

# Banks
u_banks <- psged(resid_banks,
                 mean = 0,
                 sd   = 1,
                 nu   = coef(fit_banks)["shape"],
                 xi   = coef(fit_banks)["skew"])
ks_banks <- ks.test(u_banks, "punif", 0, 1)
cat("Kolmogorov‚ÄìSmirnov p-value (Banks):", round(ks_banks$p.value, 4), "\n")

# FinancialServices
u_financialservices <- psged(resid_financialservices,
                 mean = 0,
                 sd   = 1,
                 nu   = coef(fit_financialservices)["shape"],
                 xi   = coef(fit_financialservices)["skew"])
ks_financialservices <- ks.test(u_financialservices, "punif", 0, 1)
cat("Kolmogorov‚ÄìSmirnov p-value (FinancialServices):", round(ks_financialservices$p.value, 4), "\n")

# Insurance
u_insurance <- psged(resid_insurance,
                 mean = 0,
                 sd   = 1,
                 nu   = coef(fit_insurance)["shape"],
                 xi   = coef(fit_insurance)["skew"])
ks_insurance <- ks.test(u_insurance, "punif", 0, 1)
cat("Kolmogorov‚ÄìSmirnov p-value (Insurance):", round(ks_insurance$p.value, 4), "\n")

# Finance
u_finance <- psged(resid_finance,
                 mean = 0,
                 sd   = 1,
                 nu   = coef(fit_finance)["shape"],
                 xi   = coef(fit_finance)["skew"])
ks_finance <- ks.test(u_finance, "punif", 0, 1)
cat("Kolmogorov‚ÄìSmirnov p-value (Finance):", round(ks_finance$p.value, 4), "\n")

# =============================================================
#  Ki·ªÉm tra tr·ª±c quan (kh√¥ng b·∫Øt bu·ªôc)
# =============================================================
par(mfrow = c(1,3))
hist(u_realestate, main = "U(0,1) RealEstate", breaks = 20)
hist(u_banks, main = "U(0,1) Banks", breaks = 20)
hist(u_financialservices, main = "U(0,1) FinancialServices", breaks = 20)
hist(u_insurance, main = "U(0,1) Insurance", breaks = 20)
hist(u_finance, main = "U(0,1) Finance", breaks = 20)

# =============================================================
#  G·ªôp l·∫°i th√†nh ma tr·∫≠n U ƒë·ªÉ d√πng cho Copula
# =============================================================
U_matrix <- cbind(u_realestate, u_banks, u_financialservices, u_insurance, u_finance)
colnames(U_matrix) <- c("RealEstate", "Banks", "FinancialServices","Insurance","Finance")

head(U_matrix)
```
```{r}
# Danh s√°ch copula th·ª≠
copula_list <- c("normal", "t", "clayton", "gumbel", "frank")

# Danh s√°ch c·∫∑p ng√†nh mu·ªën ch·∫°y copula
pairs_list <- list(
  c("RealEstate", "Banks"),
  c("RealEstate", "FinancialServices"),
  c("RealEstate","Insurance"),
  c("RealEstate","Finance")
)

# Data U ƒë√£ chu·∫©n h√≥a
U_matrix <- cbind(u_realestate, u_banks, u_financialservices,u_insurance,u_finance)
colnames(U_matrix) <- c("RealEstate", "Banks", "FinancialServices","Insurance","Finance")

# L∆∞u k·∫øt qu·∫£
results_copula <- list()

# V√≤ng l·∫∑p qua c√°c c·∫∑p
for(pair in pairs_list){
  
  cat("===== Pair:", pair[1], "-", pair[2], "=====\n")
  U_pair <- U_matrix[, pair]
  
  results_pair <- data.frame(
    Copula = character(),
    Param1 = numeric(),
    Param2 = numeric(),
    DF = numeric(),
    LogLik = numeric(),
    AIC = numeric(),
    BIC = numeric(),
    stringsAsFactors = FALSE
  )
  
  for(cop_name in copula_list){
    # Kh·ªüi t·∫°o copula
    cop <- switch(cop_name,
                  normal = normalCopula(dim = 2, dispstr = "un"),
                  t = tCopula(dim = 2, dispstr = "un", df = 4, df.fixed = FALSE),
                  clayton = claytonCopula(dim = 2),
                  gumbel = gumbelCopula(dim = 2),
                  frank = frankCopula(dim = 2))
    
    # Fit copula
    fit <- tryCatch({
      fitCopula(cop, data = U_pair, method = "ml")
    }, error = function(e){
      cat(" ‚ö†Ô∏è L·ªói fit copula", cop_name, "\n")
      return(NULL)
    })
    
    if(!is.null(fit)){
      params <- coef(fit)
      param1 <- params[1]
      param2 <- ifelse(length(params) > 1, params[2], NA)
      df_val <- if(cop_name == "t") tail(params, 1) else NA
      ll <- logLik(fit)
      aic_val <- AIC(fit)
      bic_val <- BIC(fit)
      
      results_pair <- rbind(results_pair, data.frame(
        Copula = cop_name,
        Param1 = param1,
        Param2 = param2,
        DF = df_val,
        LogLik = ll,
        AIC = aic_val,
        BIC = bic_val
      ))
      
      cat("Copula:", cop_name, "| Param1:", round(param1,4),
          "| Param2:", ifelse(is.na(param2), "-", round(param2,4)),
          "| DF:", ifelse(is.na(df_val), "-", round(df_val,4)),
          "| LogLik:", round(ll,4),
          "| AIC:", round(aic_val,4),
          "| BIC:", round(bic_val,4), "\n")
    }
  }
  
  results_copula[[paste(pair, collapse = "-")]] <- results_pair
  cat("------------------------------------------------------------\n")
}

# Xem k·∫øt qu·∫£ t√≥m t·∫Øt
results_copula

```

## 5. DCC-GARCH
```{r}

# ==============================
# B∆∞·ªõc 1. X√¢y m√¥ h√¨nh DCC‚ÄìT cho t·ª´ng c·∫∑p
# ==============================

# ƒê·ªãnh nghƒ©a m√¥ h√¨nh DCC-T (Student-t Copula)
uspec <- ugarchspec(mean.model = list(armaOrder = c(2,4),include.mean = FALSE), 
                    variance.model = list(garchOrder = c(3,2)), 
                    distribution.model = "sged")

# H√†m ph·ª•: fit DCC cho 2 ng√†nh v√† tr√≠ch k·∫øt qu·∫£
fit_dcc_pair <- function(series1, series2, name1, name2) {
  # Gom d·ªØ li·ªáu 2 ng√†nh, b·ªè NA
  data_pair <- na.omit(cbind(series1, series2))
  colnames(data_pair) <- c(name1, name2)
  
  # ƒê·ªãnh nghƒ©a DCC‚ÄìT Copula
  dcc_spec <- dccspec(
    uspec = multispec(replicate(2, uspec)),
    dccOrder = c(1,1),
    distribution = "mvt"   # multivariate Student-t
  )
  
  # Fit m√¥ h√¨nh DCC
  dcc_fit <- dccfit(dcc_spec, data = data_pair, fit.control = list(eval.se = TRUE))
  
  # L·∫•y tham s·ªë ∆∞·ªõc l∆∞·ª£ng
  params <- as.data.frame(dcc_fit@mfit$matcoef)
  colnames(params) <- c("Estimate", "t_value")
  
  # T√¨m gi√° tr·ªã alpha, beta, nu (dof)
  alpha <- params["[Joint]dcca1", ]
  beta  <- params["[Joint]dccb1", ]
  nu    <- params["[Joint]mshape", ]
  
  # AIC, BIC, Log Likelihood
  AIC_value <- infocriteria(dcc_fit)[1]
  BIC_value <- infocriteria(dcc_fit)[2]
  LL_value  <- likelihood(dcc_fit)
  
  # Gom th√†nh b·∫£ng k·∫øt qu·∫£
  result <- data.frame(
    Pair = paste(name1, "-", name2),
    nu = round(nu$Estimate, 4),
    nu_t = round(nu$t_value, 4),
    alpha = round(alpha$Estimate, 4),
    alpha_t = round(alpha$t_value, 4),
    beta = round(beta$Estimate, 4),
    beta_t = round(beta$t_value, 4),
    AIC = round(AIC_value, 4),
    BIC = round(BIC_value, 4),
    LogLik = round(LL_value, 4)
  )
  
  # Tr·∫£ k·∫øt qu·∫£ + m√¥ h√¨nh ƒë·ªÉ v·∫Ω t∆∞∆°ng quan ƒë·ªông
  return(list(result = result, model = dcc_fit))
}

# ==============================
# B∆∞·ªõc 2. Ch·∫°y t·ª´ng c·∫∑p
# ==============================
result_RE_Banks <- fit_dcc_pair(industry_return$RealEstate, industry_return$Banks, "RealEstate", "Banks")
result_RE_Financial <- fit_dcc_pair(industry_return$RealEstate, industry_return$FinancialServices, "RealEstate", "FinancialServices")
result_RE_Insurance <- fit_dcc_pair(industry_return$RealEstate, industry_return$Insurance, "RealEstate", "Insurance")
result_RE_Finance <- fit_dcc_pair(industry_return$RealEstate, industry_return$Finance, "RealEstate", "Finance")

# ==============================
# B∆∞·ªõc 3. G·ªôp k·∫øt qu·∫£ th√†nh b·∫£ng
# ==============================
final_results <- rbind(result_RE_Banks$result,
                       result_RE_Financial$result,
                       result_RE_Insurance$result,
                       result_RE_Finance$result)

print(final_results)

# ==============================
# B∆∞·ªõc 4. V·∫Ω t∆∞∆°ng quan ƒë·ªông
# ==============================
R_t_RE_Banks <- rcor(result_RE_Banks$model)   # ma tr·∫≠n t∆∞∆°ng quan ƒë·ªông
corr_RE_Banks <- R_t_RE_Banks[1,2,]           # h·ªá s·ªë t∆∞∆°ng quan gi·ªØa 2 ng√†nh
plot(corr_RE_Banks, type = "l", col = "blue",
     main = "Dynamic Correlation: RealEstate - Banks",
     ylab = "Correlation", xlab = "Time")

R_t_RE_FinancialServices <- rcor(result_RE_Financial$model)   # ma tr·∫≠n t∆∞∆°ng quan ƒë·ªông
corr_RE_FinancialServices <- R_t_RE_FinancialServices[1,2,]           # h·ªá s·ªë t∆∞∆°ng quan gi·ªØa 2 ng√†nh
plot(corr_RE_FinancialServices, type = "l", col = "blue",
     main = "Dynamic Correlation: RealEstate - FinancialServices",
     ylab = "Correlation", xlab = "Time")

R_t_RE_Insurance <- rcor(result_RE_Insurance$model)   # ma tr·∫≠n t∆∞∆°ng quan ƒë·ªông
corr_RE_Insurance <- R_t_RE_Insurance[1,2,]           # h·ªá s·ªë t∆∞∆°ng quan gi·ªØa 2 ng√†nh
plot(corr_RE_Insurance, type = "l", col = "blue",
     main = "Dynamic Correlation: RealEstate - Insurance",
     ylab = "Correlation", xlab = "Time")

R_t_RE_Finance <- rcor(result_RE_Finance$model)   # ma tr·∫≠n t∆∞∆°ng quan ƒë·ªông
corr_RE_Finance <- R_t_RE_Finance[1,2,]           # h·ªá s·ªë t∆∞∆°ng quan gi·ªØa 2 ng√†nh
plot(corr_RE_Finance, type = "l", col = "blue",
     main = "Dynamic Correlation: RealEstate - Finance",
     ylab = "Correlation", xlab = "Time")
```
```{r}
acf(corr_RE_Banks, main="ACF of dynamic correlation between Real Estate and Banks")
acf(corr_RE_FinancialServices, main="ACF of dynamic correlation between Real Estate and Financial Services")
acf(corr_RE_Insurance, main="ACF of dynamic correlation between Real Estate and Insurance")
acf(corr_RE_Finance, main="ACF of dynamic correlation between Real Estate and Finance")
```

## 6. T√≠nh CoVaR c√°c ng√†nh t√†i ch√≠nh
### 6.1. T√≠nh CoVaR khi Real Estate ·ªü tr·∫°ng th√°i VaR
```{r}
alpha_level <- 0.05  # m·ª©c tin c·∫≠y 95%

# H√†m t√≠nh VaR theo ng√†nh
compute_VaR_sged <- function(fit, alpha_level) {
  mu_i <- 0  # do m√¥ h√¨nh tr∆∞·ªõc d√πng include.mean = FALSE
  sigma_t <- sigma(fit)    # volatility ƒë·ªông theo th·ªùi ƒëi·ªÉm
  skew_i <- coef(fit)["skew"]
  shape_i <- coef(fit)["shape"]
  
  VaR <- mu_i + sigma_t * qdist("sged", 
                                p = alpha_level, 
                                mu = 0, sigma = 1, 
                                skew = skew_i, 
                                shape = shape_i)
  return(VaR)
}

# T√≠nh VaR cho t·ª´ng ng√†nh
VaR_realestate       <- compute_VaR_sged(fit_realestate, alpha_level)
VaR_banks            <- compute_VaR_sged(fit_banks, alpha_level)
VaR_financialservices <- compute_VaR_sged(fit_financialservices, alpha_level)
VaR_insurance        <- compute_VaR_sged(fit_insurance, alpha_level)
VaR_finance          <- compute_VaR_sged(fit_finance, alpha_level)

# T·∫°o dataframe
VaR_df <- data.frame(
  Date = industry_return$Date[-1],  # b·ªè NA ƒë·∫ßu n·∫øu c·∫ßn
  RealEstate = VaR_realestate,
  Banks = VaR_banks,
  FinancialServices = VaR_financialservices,
  Insurance = VaR_insurance,
  Finance = VaR_finance
)

head(VaR_df)
```


```{r}
#H√†m t√≠nh CoVaR
compute_CoVaR_TDCC_full <- function(u_i,         # uniform c·ªßa sector i (conditioning) (0-1)
                                   u_j,         # uniform c·ªßa sector j (target) (0-1)
                                   dcc_model,   # fitted DCC model object
                                   mu_j,        # conditional mean t·ª´ GARCH fit c·ªßa j
                                   sigma_j,     # conditional sigma t·ª´ GARCH fit c·ªßa j
                                   alpha_VaR,  # m·ª©c r·ªßi ro
                                   alpha_CoVaR
                                   ) {
  
  n <- length(u_i)
  if(length(u_j)!=n || length(mu_j)!=n || length(sigma_j)!=n) stop("C√°c vector ph·∫£i c√πng chi·ªÅu.")
  
  # ----- l·∫•y rho_t t·ª´ DCC -----
  rho_arr <- rcor(dcc_model)   # dim (nAssets, nAssets, n)
  rho_t <- rho_arr[1,2,]
  n <- min(n, length(rho_t))
  u_i <- u_i[1:n]; u_j <- u_j[1:n]; mu_j <- mu_j[1:n]; sigma_j <- sigma_j[1:n]; rho_t <- rho_t[1:n]
  
  # ----- l·∫•y degree of freedom (nu) t·ª´ DCC -----
  nu <- NA
  mat <- dcc_model@mfit$matcoef
  possible_names <- c("nu","[Joint]mshape","mshape","shape","dof","dof1")
  for(nm in possible_names){
    if(nm %in% rownames(mat)) {nu <- as.numeric(mat[nm," Estimate"]); break}
  }
  if(is.na(nu)) stop("Kh√¥ng t√¨m ƒë∆∞·ª£c nu trong dcc_model")
  
  # ----- chu·∫©n b·ªã output -----
  CoVaR_u    <- numeric(n)
  CoVaR_qt   <- numeric(n)
  
  eps <- 1e-8
  u_i <- pmin(pmax(u_i, eps), 1-eps)
  u_j <- pmin(pmax(u_j, eps), 1-eps)
  
  # ----- v√≤ng t√≠nh CoVaR -----
  for(t in 1:n){
    rho <- pmin(pmax(rho_t[t], -0.9999), 0.9999)
    x_t <- qt(alpha_VaR, df=nu)  # VaR_i t-scale
    mean_c <- rho * x_t
    sd_c   <- sqrt((nu + x_t^2)/(nu+1) * (1 - rho^2))
    q_cond_t <- mean_c + sd_c * qt(alpha_CoVaR, df=nu+1)
    
    # map v·ªÅ uniform
    CoVaR_u[t] <- pt(q_cond_t, df=nu)
    CoVaR_qt[t] <- q_cond_t
  }
  
  return(list(
    CoVaR_u = CoVaR_u,   # uniform
    CoVaR_qt = CoVaR_qt, # t-scale
    nu = nu,
    rho_t = rho_t
  ))
}
```
```{r}
#CoVaR Real Estate - Banks
mu_banks    <- rep(0, length(u_realestate))
sigma_t_banks <- sigma(fit_banks)

# ----- Step 3: g·ªçi h√†m CoVaR -----
CoVaR_out <- compute_CoVaR_TDCC_full(
  u_i = u_realestate,     # conditioning sector = RealEstate
  u_j = u_banks,          # target sector = Banks
  dcc_model = result_RE_Banks$model,
  mu_j = mu_banks,
  sigma_j = sigma_t_banks,
  alpha_VaR = 0.05,
  alpha_CoVaR = 0.05
)

# ----- Step 4: map t·ª´ uniform -> quantile SGED -----
shape_banks <- fit_banks@fit$matcoef["shape"," Estimate"]
skew_banks  <- fit_banks@fit$matcoef["skew"," Estimate"]

q_sged_RE_banks <- qsged(CoVaR_out$CoVaR_u, nu = shape_banks, xi=skew_banks)  # quantile SGED

# ----- Step 5: scale v·ªÅ return g·ªëc -----
CoVaR_Banks_given_RE <- 0 + sigma_t_banks * q_sged_RE_banks

# ----- Step 6: xem k·∫øt qu·∫£ -----
head(CoVaR_Banks_given_RE)
summary(CoVaR_Banks_given_RE)
plot(industry_return$Date[-1],CoVaR_Banks_given_RE, type="l", main="CoVaR Banks | RealEstate (alpha=0.05)")
```


```{r}
#CoVaR Real Estate - Financial Services
mu_financialservices <- rep(0, length(u_realestate))
sigma_t_financialservices <- sigma(fit_financialservices)

# ----- Step 3: g·ªçi h√†m CoVaR -----
CoVaR_out <- compute_CoVaR_TDCC_full(
  u_i = u_realestate,     # conditioning sector = RealEstate
  u_j = u_financialservices,          # target sector = FinancialServices
  dcc_model = result_RE_Financial$model,
  mu_j = mu_financialservices,
  sigma_j = sigma_t_financialservices,
  alpha_VaR = 0.05,
  alpha_CoVaR = 0.05
)

# ----- Step 4: map t·ª´ uniform -> quantile SGED -----
shape_financialservices <- fit_financialservices@fit$matcoef["shape"," Estimate"]
skew_financialservices  <- fit_financialservices@fit$matcoef["skew"," Estimate"]

q_sged_RE_financialservices <- qsged(CoVaR_out$CoVaR_u, nu = shape_financialservices, xi=skew_financialservices)  # quantile SGED

# ----- Step 5: scale v·ªÅ return g·ªëc -----
CoVaR_financial_given_RE <- 0 + sigma_t_financialservices * q_sged_RE_financialservices

# ----- Step 6: xem k·∫øt qu·∫£ -----
head(CoVaR_financial_given_RE)
summary(CoVaR_financial_given_RE)
plot(industry_return$Date[-1],CoVaR_financial_given_RE, type="l", main="CoVaR FinancialServices | RealEstate (alpha=0.05)")
```

```{r}
#CoVaR Real Estate - Insurance
mu_insurance <- rep(0, length(u_realestate))
sigma_t_insurance <- sigma(fit_insurance)

# ----- Step 3: g·ªçi h√†m CoVaR -----
CoVaR_out <- compute_CoVaR_TDCC_full(
  u_i = u_realestate,     # conditioning sector = RealEstate
  u_j = u_insurance,          # target sector = Insurance
  dcc_model = result_RE_Insurance$model,
  mu_j = mu_insurance,
  sigma_j = sigma_t_insurance,
  alpha_VaR = 0.05,
  alpha_CoVaR = 0.05
)

# ----- Step 4: map t·ª´ uniform -> quantile SGED -----
shape_insurance <- fit_insurance@fit$matcoef["shape"," Estimate"]
skew_insurance  <- fit_insurance@fit$matcoef["skew"," Estimate"]

q_sged_RE_insurance <- qsged(CoVaR_out$CoVaR_u, nu = shape_insurance, xi=skew_insurance)  # quantile SGED

# ----- Step 5: scale v·ªÅ return g·ªëc -----
CoVaR_insurance_given_RE <- 0 + sigma_t_insurance * q_sged_RE_insurance

# ----- Step 6: xem k·∫øt qu·∫£ -----
head(CoVaR_insurance_given_RE)
summary(CoVaR_insurance_given_RE)
plot(industry_return$Date[-1],CoVaR_insurance_given_RE, type="l", main="CoVaR Insurance | RealEstate (alpha=0.05)")
```
```{r}
#CoVaR Real Estate - Finance
mu_finance <- rep(0, length(u_realestate))
sigma_t_finance <- sigma(fit_finance)

# ----- Step 3: g·ªçi h√†m CoVaR -----
CoVaR_out <- compute_CoVaR_TDCC_full(
  u_i = u_realestate,     # conditioning sector = RealEstate
  u_j = u_finance,          # target sector = Finance
  dcc_model = result_RE_Finance$model,
  mu_j = mu_finance,
  sigma_j = sigma_t_finance,
  alpha_VaR = 0.05,
  alpha_CoVaR = 0.05
)

# ----- Step 4: map t·ª´ uniform -> quantile SGED -----
shape_finance <- fit_finance@fit$matcoef["shape"," Estimate"]
skew_finance  <- fit_finance@fit$matcoef["skew"," Estimate"]

q_sged_RE_finance <- qsged(CoVaR_out$CoVaR_u, nu = shape_finance, xi=skew_finance)  # quantile SGED

# ----- Step 5: scale v·ªÅ return g·ªëc -----
CoVaR_finance_given_RE <- 0 + sigma_t_finance * q_sged_RE_finance

# ----- Step 6: xem k·∫øt qu·∫£ -----
head(CoVaR_finance_given_RE)
summary(CoVaR_finance_given_RE)
plot(industry_return$Date[-1],CoVaR_finance_given_RE, type="l", main="CoVaR Finance | RealEstate (alpha=0.05)")
```

```{r}
library(dplyr)
library(lubridate)

# L·∫≠p b·∫£ng daily CoVaR
CoVaR_data <- data.frame(
  Date = industry_return$Date[-1],
  Banks = CoVaR_Banks_given_RE,
  FinancialServices = CoVaR_financial_given_RE,
  Insurance = CoVaR_insurance_given_RE,
  Finance = CoVaR_finance_given_RE
)

# Th√™m c·ªôt Year
CoVaR_data <- CoVaR_data %>%
  mutate(Year = year(Date))

# T√≠nh average annual CoVaR
CoVaR_annual <- CoVaR_data %>%
  group_by(Year) %>%
  summarise(
    Banks = mean(Banks, na.rm = TRUE),
    FinancialServices = mean(FinancialServices, na.rm = TRUE),
    Insurance = mean(Insurance, na.rm = TRUE),
    Finance = mean(Finance, na.rm = TRUE)
  )

# Hi·ªÉn th·ªã b·∫£ng
print(CoVaR_annual, digits = 4)
```

### 6.2. T√≠nh CoVaR khi Real Estate ·ªü tr·∫°ng th√°i Median
```{r}
#T√≠nh median cho t·ª´ng ng√†nh
alpha_level <- 0.5  # m·ª©c tin c·∫≠y 50%

# H√†m t√≠nh median theo ng√†nh
compute_VaR_sged_1 <- function(fit, alpha_level) {
  mu_i <- 0  # do m√¥ h√¨nh tr∆∞·ªõc d√πng include.mean = FALSE
  sigma_t <- sigma(fit)    # volatility ƒë·ªông theo th·ªùi ƒëi·ªÉm
  skew_i <- coef(fit)["skew"]
  shape_i <- coef(fit)["shape"]
  
  VaR <- mu_i + sigma_t * qdist("sged", 
                                p = alpha_level, 
                                mu = 0, sigma = 1, 
                                skew = skew_i, 
                                shape = shape_i)
  return(VaR)
}

# T√≠nh median cho t·ª´ng ng√†nh
median_realestate      <- compute_VaR_sged(fit_realestate, alpha_level)
median_banks            <- compute_VaR_sged(fit_banks, alpha_level)
median_financialservices <- compute_VaR_sged(fit_financialservices, alpha_level)
median_insurance        <- compute_VaR_sged(fit_insurance, alpha_level)
median_finance          <- compute_VaR_sged(fit_finance, alpha_level)

# T·∫°o dataframe
median_df <- data.frame(
  Date = industry_return$Date[-1],  # b·ªè NA ƒë·∫ßu n·∫øu c·∫ßn
  RealEstate = median_realestate,
  Banks = median_banks,
  FinancialServices = median_financialservices,
  Insurance = median_insurance,
  Finance = median_finance
)

head(median_df)
```

```{r}
#T√≠nh CoVaR t·∫°i khi Real Estate b√¨nh th∆∞·ªùng (median)

#CoVaR Real Estate - Banks 
mu_banks    <- rep(0, length(u_realestate))
sigma_t_banks <- sigma(fit_banks)

# ----- Step 3: g·ªçi h√†m CoVaR -----
CoVaR_out <- compute_CoVaR_TDCC_full(
  u_i = u_realestate,     # conditioning sector = RealEstate
  u_j = u_banks,          # target sector = Banks
  dcc_model = result_RE_Banks$model,
  mu_j = mu_banks,
  sigma_j = sigma_t_banks,
  alpha_VaR = 0.5,
  alpha_CoVaR = 0.05
)

# ----- Step 4: map t·ª´ uniform -> quantile SGED -----
shape_banks <- fit_banks@fit$matcoef["shape"," Estimate"]
skew_banks  <- fit_banks@fit$matcoef["skew"," Estimate"]

q_sged_RE_banks <- qsged(CoVaR_out$CoVaR_u, nu = shape_banks, xi=skew_banks)  # quantile SGED

# ----- Step 5: scale v·ªÅ return g·ªëc -----
CoVaR_Banks_given_median_RE <- 0 + sigma_t_banks * q_sged_RE_banks

# ----- Step 6: xem k·∫øt qu·∫£ -----
head(CoVaR_Banks_given_median_RE)
summary(CoVaR_Banks_given_median_RE)
plot(industry_return$Date[-1],CoVaR_Banks_given_median_RE, type="l", main="CoVaR Banks | RealEstate (alpha=0.5)")
```
```{r}
#CoVaR Real Estate - Financial Services
mu_financialservices <- rep(0, length(u_realestate))
sigma_t_financialservices <- sigma(fit_financialservices)

# ----- Step 3: g·ªçi h√†m CoVaR -----
CoVaR_out <- compute_CoVaR_TDCC_full(
  u_i = u_realestate,     # conditioning sector = RealEstate
  u_j = u_financialservices,          # target sector = FinancialServices
  dcc_model = result_RE_Financial$model,
  mu_j = mu_financialservices,
  sigma_j = sigma_t_financialservices,
  alpha_VaR = 0.5,
  alpha_CoVaR = 0.05
)

# ----- Step 4: map t·ª´ uniform -> quantile SGED -----
shape_financialservices <- fit_financialservices@fit$matcoef["shape"," Estimate"]
skew_financialservices  <- fit_financialservices@fit$matcoef["skew"," Estimate"]

q_sged_RE_financialservices <- qsged(CoVaR_out$CoVaR_u, nu = shape_financialservices, xi=skew_financialservices)  # quantile SGED

# ----- Step 5: scale v·ªÅ return g·ªëc -----
CoVaR_financial_given_median_RE <- 0 + sigma_t_financialservices * q_sged_RE_financialservices

# ----- Step 6: xem k·∫øt qu·∫£ -----
head(CoVaR_financial_given_median_RE)
summary(CoVaR_financial_given_median_RE)
plot(industry_return$Date[-1],CoVaR_financial_given_median_RE, type="l", main="CoVaR FinancialServices | RealEstate (alpha=0.5)")
```
```{r}
#CoVaR Real Estate - Insurance
mu_insurance <- rep(0, length(u_realestate))
sigma_t_insurance <- sigma(fit_insurance)

# ----- Step 3: g·ªçi h√†m CoVaR -----
CoVaR_out <- compute_CoVaR_TDCC_full(
  u_i = u_realestate,     # conditioning sector = RealEstate
  u_j = u_insurance,          # target sector = Insurance
  dcc_model = result_RE_Insurance$model,
  mu_j = mu_insurance,
  sigma_j = sigma_t_insurance,
  alpha_VaR = 0.5,
  alpha_CoVaR = 0.05
)

# ----- Step 4: map t·ª´ uniform -> quantile SGED -----
shape_insurance <- fit_insurance@fit$matcoef["shape"," Estimate"]
skew_insurance  <- fit_insurance@fit$matcoef["skew"," Estimate"]

q_sged_RE_insurance <- qsged(CoVaR_out$CoVaR_u, nu = shape_insurance, xi=skew_insurance)  # quantile SGED

# ----- Step 5: scale v·ªÅ return g·ªëc -----
CoVaR_insurance_given_median_RE <- 0 + sigma_t_insurance * q_sged_RE_insurance

# ----- Step 6: xem k·∫øt qu·∫£ -----
head(CoVaR_insurance_given_median_RE)
summary(CoVaR_insurance_given_median_RE)
plot(industry_return$Date[-1],CoVaR_insurance_given_median_RE, type="l", main="CoVaR Insurance | RealEstate (alpha=0.5)")
```


```{r}
#CoVaR Real Estate - Finance
mu_finance <- rep(0, length(u_realestate))
sigma_t_finance <- sigma(fit_finance)

# ----- Step 3: g·ªçi h√†m CoVaR -----
CoVaR_out <- compute_CoVaR_TDCC_full(
  u_i = u_realestate,     # conditioning sector = RealEstate
  u_j = u_finance,          # target sector = Finance
  dcc_model = result_RE_Finance$model,
  mu_j = mu_finance,
  sigma_j = sigma_t_finance,
  alpha_VaR = 0.5,
  alpha_CoVaR = 0.05
)

# ----- Step 4: map t·ª´ uniform -> quantile SGED -----
shape_finance <- fit_finance@fit$matcoef["shape"," Estimate"]
skew_finance  <- fit_finance@fit$matcoef["skew"," Estimate"]

q_sged_RE_finance <- qsged(CoVaR_out$CoVaR_u, nu = shape_finance, xi=skew_finance)  # quantile SGED

# ----- Step 5: scale v·ªÅ return g·ªëc -----
CoVaR_finance_given_median_RE <- 0 + sigma_t_finance * q_sged_RE_finance

# ----- Step 6: xem k·∫øt qu·∫£ -----
head(CoVaR_finance_given_median_RE)
summary(CoVaR_finance_given_median_RE)
plot(industry_return$Date[-1],CoVaR_finance_given_median_RE, type="l", main="CoVaR Finance | RealEstate (alpha=0.5)")
```

## 7. T√≠nh deltaCoVaR
```{r}
#T√≠nh deltaCoVaR

# ====================================
# B∆∞·ªõc 1: T√≠nh deltaCoVaR theo ng√†y
# ====================================
percent_CoVaR <- data.frame(
  Date = industry_return$Date[-1],
  Banks = (CoVaR_Banks_given_RE - CoVaR_Banks_given_median_RE) ,
  FinancialServices = (CoVaR_financial_given_RE - CoVaR_financial_given_median_RE) ,
  Insurance = (CoVaR_insurance_given_RE - CoVaR_insurance_given_median_RE),
  Finance = (CoVaR_finance_given_RE- CoVaR_finance_given_median_RE))
# V·∫Ω
plot(percent_CoVaR$Banks, type = "l", col = "red",
     main = "deltaCoVaR (Banks | Real Estate)", ylab = "deltaCoVaR", xlab = "Time")

plot(percent_CoVaR$FinancialServices, type = "l", col = "red",
     main = "deltaCoVaR (Financial Services | Real Estate)", ylab = "deltaCoVaR", xlab = "Time")

plot(percent_CoVaR$Insurance, type = "l", col = "red",
     main = "deltaCoVaR (Insurance | Real Estate)", ylab = "deltaCoVaR", xlab = "Time")

plot(percent_CoVaR$Finance, type = "l", col = "red",
     main = "deltaCoVaR (Finance | Real Estate)", ylab = "deltaCoVaR", xlab = "Time")
```

```{r}
# Th√™m c·ªôt Year
percent_CoVaR <- percent_CoVaR %>%
  mutate(Year = year(Date))

# T√≠nh average annual deltaCoVaR 
percent_CoVaR_annual <- percent_CoVaR %>%
  group_by(Year) %>%
  summarise(
    Banks = mean(Banks, na.rm = TRUE),
    FinancialServices = mean(FinancialServices, na.rm = TRUE),
    Insurance = mean(Insurance, na.rm = TRUE),
    Finance = mean(Finance, na.rm = TRUE)
  )

# Hi·ªÉn th·ªã b·∫£ng
print(percent_CoVaR_annual, digits = 4)
```

